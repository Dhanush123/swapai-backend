// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

// 3rd-party library imports
import { Chainlink, ChainlinkClient } from "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import { AggregatorV3Interface } from "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

// 1st-party project imports
import { Constants } from "./Constants.sol";
import { TokenSwapper } from "./TokenSwapper.sol";
import { SwapUser, PredictionResponse } from "./DataStructures.sol";

// Chainlink oracle code goes here
contract OracleMasterV2 is ChainlinkClient {
  bool private force;
  TokenSwapper private swapper;
  SwapUser[] private currentUsersToSwap;
  PredictionResponse private response;

  event AutoSwapUsersBalances(
    SwapUser[] users,
    PredictionResponse response
  );

  event ManualSwapUsersBalances(
    SwapUser[] users,
    bool direction
  );

  constructor() public {
    swapper = new TokenSwapper();
  }

  function startPredictionAnalysis() private {
    response = PredictionResponse(0, 0, 0, false, false);

    // requestTUSDRatio();
    requestBTCSentiment();
    requestBTCPriceCurrent();
    requestBTCPricePrediction();
  }

  /////////////////////
  // Currency Ratios //
  /////////////////////
  
  // function requestTUSDRatio() internal {
  //   Chainlink.Request memory req = buildChainlinkRequest(
  //     Constants.TUSD_RATIO_JOB_ID,
  //     address(this),
  //     this.getTUSDRatio.selector
  //   );

  //   sendChainlinkRequestTo(
  //     Constants.TUSD_RATIO_ORACLE_ADDR,
  //     req,
  //     1 * Constants.LINK
  //   );
  // }

  // function getTUSDRatio(bytes32 _requestID, uint _ratio) public recordChainlinkFulfillment(_requestID) {
  //   response.tusdRatio = _ratio;
  //   tryExecutingSwap(response);
  // }

  ///////////////////////////
  // BTC Sentiment Analyis //
  ///////////////////////////

  function requestBTCSentiment() internal {
    Chainlink.Request memory req = buildChainlinkRequest(
      Constants.SENTIMENT_JOB_ID,
      address(this),
      this.getBTCSentiment.selector
    );

    req.add("token", "BTC");
    req.add("period", "24");

    sendChainlinkRequestTo(
      Constants.SENTIMENT_ORACLE_ADDR,
      req,
      0.1 * Constants.LINK
    );
  }

  function getBTCSentiment(bytes32 _requestID, uint _btcSentiment) public recordChainlinkFulfillment(_requestID) {
    response.btcSentiment = _btcSentiment;
    tryExecutingSwap(response);
  }

  ///////////////////////
  // BTC Current Price //
  ///////////////////////
  
  function requestBTCPriceCurrent() internal {
    AggregatorV3Interface priceFeed = AggregatorV3Interface(Constants.BTC_USD_PRICE_FEED_ADDR);
    (,int price,,,) = priceFeed.latestRoundData();

    // NOTE: We're assuming that price will *never* be negative
    response.btcPriceCurrent = uint(price);
    tryExecutingSwap(response);
  }

  ///////////////////////////
  // BTC Price Predictions //
  ///////////////////////////

  function requestBTCPricePrediction() internal {
    Chainlink.Request memory req = buildChainlinkRequest(
      Constants.PRICE_JOB_ID,
      address(this),
      this.getBTCPricePrediction.selector
    );

    req.add("days", "1");

    sendChainlinkRequestTo(
      Constants.PRICE_ORACLE_ADDR,
      req,
      1 * Constants.LINK
    );
  }

  function getBTCPricePrediction(bytes32 _requestID, uint _btcPricePrediction) public recordChainlinkFulfillment(_requestID) {
    response.btcPricePrediction = _btcPricePrediction;
    tryExecutingSwap(response);
  }

  /////////////////////////////
  // Post Processing Results //
  /////////////////////////////

  function isResultReady(PredictionResponse memory res) private pure returns (bool) {
    return /*res.tusdRatio != 0 &&*/ res.btcSentiment != 0 &&
      res.btcPriceCurrent != 0 && res.btcPricePrediction != 0;
  }

  function tryExecutingSwap(PredictionResponse memory res) public {
    if (isResultReady(res)) {
      // bool isInsufficientTUSDRatio = tusdRatio < 9999; // 10000 means 1:1 asset:reserve ratio, less means $ assets > $ reserves
      bool isNegativeBTCSentiment = response.btcSentiment < 2500; // 5000 means 0.5 sentiment from range [-1,1]
      bool isBTCPriceGoingDown = (response.btcPriceCurrent / response.btcPricePrediction * 10**8) > 105000000; // check if > 5% decrease
      response.isNegativeFuture = /*isInsufficientTUSDRatio ||*/ isNegativeBTCSentiment || isBTCPriceGoingDown;

      // bool isSufficientTUSDRatio = tusdRatio >= 10000;
      bool isPositiveBTCSentiment = response.btcSentiment > 7500;
      bool isBTCPriceGoingUp = (response.btcPriceCurrent / response.btcPricePrediction * 10**8) < 95000000; // check if > 5% increase
      response.isPositiveFuture = /*isSufficientTUSDRatio &&*/ isPositiveBTCSentiment && isBTCPriceGoingUp;

      for (uint i = 0; i < currentUsersToSwap.length; i++) {
        swapper.doAutoSwap(currentUsersToSwap[i], response.isPositiveFuture, response.isNegativeFuture);
      }

      emit AutoSwapUsersBalances(currentUsersToSwap, response);
    }
  }

  // Should only be called by keeper
  function trySwapAuto(SwapUser[] memory _currentUsersToSwap, bool _force) external {
    for (uint i = 0; i < _currentUsersToSwap.length; i++) {
      currentUsersToSwap[i] = _currentUsersToSwap[i];
    }

    force = _force;
    startPredictionAnalysis();
  }

  function trySwapManual(SwapUser[] memory _currentUsersToSwap, bool swapToTUSD) external {
    for (uint i = 0; i < _currentUsersToSwap.length; i++) {
      currentUsersToSwap[i] = _currentUsersToSwap[i];
    }

    for (uint i = 0; i < currentUsersToSwap.length; i++) {
      swapper.doManualSwap(currentUsersToSwap[i], swapToTUSD);
    }

    emit ManualSwapUsersBalances(currentUsersToSwap, swapToTUSD);
  }
}

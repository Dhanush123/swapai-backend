// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

// 3rd-party library imports
import { Chainlink, ChainlinkClient } from "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import { AggregatorV3Interface } from "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

// 1st-party project imports
import { OracleAggregator } from "./utility/OracleAggregator.sol";
import { Constants } from "./Constants.sol";
import { TokenSwapper } from "./TokenSwapper.sol";
import { SwapUser, PredictionResponse, SwapDirection } from "./DataStructures.sol";

// Chainlink oracle code goes here
contract OracleMasterV3 is ChainlinkClient {
  bool private force;

  TokenSwapper private swapper;
  OracleAggregator private aggregator;

  SwapUser[] private currentUsersToSwap;
  PredictionResponse private response;

  event AutoSwapUsersBalances(
    SwapUser[] users,
    PredictionResponse response
  );

  event ManualSwapUsersBalances(
    SwapUser[] users,
    SwapDirection direction
  );

  constructor() public {
    swapper = new TokenSwapper();
    aggregator = new OracleAggregator();
  }

  function trySwapManual(SwapUser[] memory _currentUsersToSwap, SwapDirection direction) external {
    for (uint i = 0; i < _currentUsersToSwap.length; i++)
      currentUsersToSwap[i] = _currentUsersToSwap[i];

    for (uint i = 0; i < currentUsersToSwap.length; i++)
      swapper.doManualSwap(currentUsersToSwap[i], direction == SwapDirection.toTUSD);

    emit ManualSwapUsersBalances(currentUsersToSwap, direction);
  }

  // Should only be called by keeper
  function trySwapAuto(SwapUser[] memory _currentUsersToSwap) external {
    for (uint i = 0; i < _currentUsersToSwap.length; i++)
      currentUsersToSwap[i] = _currentUsersToSwap[i];

    startPredictionAnalysis();
  }

  function startPredictionAnalysis() private {
    response = PredictionResponse(0, 0, 0, false, false);

    // Add Job for Currency Ratio
    // aggregator.addJob(
    //   Constants.TUSD_RATIO_JOB_ID,
    //   address(this),
    //   this.getTUSDRatio.selector,

    //   Constants.TUSD_RATIO_ORACLE_ADDR,
    //   1 * Constants.LINK
    // );

    // Add Job for BTC Sentiment Analyis
    aggregator.addJob(
      Constants.SENTIMENT_JOB_ID,
      address(this),
      this.getBTCSentiment.selector,

      Constants.SENTIMENT_ORACLE_ADDR,
      0.1 * Constants.LINK
    );

    // Add Job for BTC Price Predictions
    aggregator.addJob(
      Constants.PRICE_JOB_ID,
      address(this),
      this.getBTCPricePrediction.selector,

      Constants.PRICE_ORACLE_ADDR,
      1 * Constants.LINK
    );

    // Execute all jobs
    aggregator.executeAll();
    requestBTCPriceCurrent();
  }

  ///////////////////////////
  // Fulfillment Functions //
  ///////////////////////////

  // function getTUSDRatio(bytes32 _requestID, uint _ratio) public recordChainlinkFulfillment(_requestID) {
  //   response.tusdRatio = _ratio;
  //   tryExecutingSwap(response);
  // }

  function getBTCSentiment(bytes32 _requestID, uint _btcSentiment) public recordChainlinkFulfillment(_requestID) {
    response.btcSentiment = _btcSentiment;
    tryExecutingSwap(response);
  }

  function getBTCPricePrediction(bytes32 _requestID, uint _btcPricePrediction) public recordChainlinkFulfillment(_requestID) {
    response.btcPricePrediction = _btcPricePrediction;
    tryExecutingSwap(response);
  }
  
  function requestBTCPriceCurrent() internal {
    AggregatorV3Interface priceFeed = AggregatorV3Interface(Constants.BTC_USD_PRICE_FEED_ADDR);
    (,int price,,,) = priceFeed.latestRoundData();

    // NOTE: We're assuming that price will *never* be negative
    response.btcPriceCurrent = uint(price);
    tryExecutingSwap(response);
  }

  /////////////////////////////
  // Post Processing Results //
  /////////////////////////////

  function isResultReady(PredictionResponse memory res) private pure returns (bool) {
    return /*res.tusdRatio != 0 &&*/ res.btcSentiment != 0 &&
      res.btcPriceCurrent != 0 && res.btcPricePrediction != 0;
  }

  function tryExecutingSwap(PredictionResponse memory res) public {
    if (isResultReady(res)) {
      // bool isInsufficientTUSDRatio = tusdRatio < 9999; // 10000 means 1:1 asset:reserve ratio, less means $ assets > $ reserves
      bool isNegativeBTCSentiment = response.btcSentiment < 2500; // 5000 means 0.5 sentiment from range [-1,1]
      bool isBTCPriceGoingDown = (response.btcPriceCurrent / response.btcPricePrediction * 10**8) > 105000000; // check if > 5% decrease
      response.isNegativeFuture = /*isInsufficientTUSDRatio ||*/ isNegativeBTCSentiment || isBTCPriceGoingDown;

      // bool isSufficientTUSDRatio = tusdRatio >= 10000;
      bool isPositiveBTCSentiment = response.btcSentiment > 7500;
      bool isBTCPriceGoingUp = (response.btcPriceCurrent / response.btcPricePrediction * 10**8) < 95000000; // check if > 5% increase
      response.isPositiveFuture = /*isSufficientTUSDRatio &&*/ isPositiveBTCSentiment && isBTCPriceGoingUp;

      for (uint i = 0; i < currentUsersToSwap.length; i++) {
        swapper.doAutoSwap(currentUsersToSwap[i], response.isPositiveFuture, response.isNegativeFuture);
      }

      emit AutoSwapUsersBalances(currentUsersToSwap, response);
    }
  }
}

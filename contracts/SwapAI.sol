// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

// 3rd-party library imports
import { KeeperCompatibleInterface } from "@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// 1st-party project imports
import { Constants } from "./Constants.sol";
import { ISwapAI } from "./interfaces/ISwapAI.sol";
import { SwapUser } from "./SwapUser.sol";
import { OracleMaster } from "./OracleMaster.sol";

contract SwapAI is ISwapAI, KeeperCompatibleInterface {
    address[] private userAddresses;
    mapping(address => SwapUser) private userData;
    OracleMaster internal oracleMaster;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval) public {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
    }

    function createUser() external override {
      if (userData[msg.sender].getUserAddress() == address(0)) {
        userData[msg.sender] = new SwapUser(msg.sender, true);
        userAddresses.push(msg.sender);
        emit CreateUser(true);
      } else {
        emit CreateUser(false);
      }
    }

    function fetchUserBalance() external override {
      emit UserBalance(
        userData[msg.sender].getTUSDBalance(),
        userData[msg.sender].getWBTCBalance()
      );
    }

    function optInToggle() external override {
      userData[msg.sender].toggleUserOptInStatus();
      emit OptInToggle(userData[msg.sender].getUserOptInStatus());
    }

    function isAtleastOneUserOptIn() private returns (bool) {
      bool result = false;
      for (uint i = 0; i < userAddresses.length; i++) {
        if (userData[userAddresses[i]].getUserOptInStatus()) {
          result = true;
          break;
        }
      }

      emit SwapEligibleUsersExist(result);
      return result;
    }

    function getSwapEligibleUsers() public view returns (SwapUser[] memory) {
      // NOTE: To avoid having a storage array (i.e. extra gas cost), we're counting the items
      // to be filtered and then instantiating a memory-based array
      uint numEligibleUsers = 0;

      for (uint i = 0; i < userAddresses.length; i++) {
        SwapUser user = userData[userAddresses[i]];
        if (user.getUserOptInStatus())
          numEligibleUsers++;
      }

      SwapUser[] memory eligibleUsers = new SwapUser[](numEligibleUsers);

      uint j = 0;
      for (uint i = 0; i < userAddresses.length; i++) {
        SwapUser user = userData[userAddresses[i]];
        if (user.getUserOptInStatus()) {
          eligibleUsers[j++] = user;
        }
      }

      return eligibleUsers;
    }

    function swapSingleUserBalance() external override {
      // HACK: This form of array initialization is used to bypass a type cast error
      SwapUser[] memory currentUserDataOnly = new SwapUser[](1);
      currentUserDataOnly[0] = userData[msg.sender];

      oracleMaster.trySwapManual(currentUserDataOnly, false);
    }

    function swapAllUsersBalances(bool force) public override {
      oracleMaster.trySwapAuto(getSwapEligibleUsers(), force);
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
      bool hasIntervalPassed = (block.timestamp - lastTimeStamp) > interval;
      upkeepNeeded = hasIntervalPassed && isAtleastOneUserOptIn();
      // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
      lastTimeStamp = block.timestamp;
      swapAllUsersBalances(false);
      // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    /////////////////////////////////////////////////////
    function depositTUSD() payable public {
      SwapUser user = userData[msg.sender];

      uint oldTUSDBalance = user.getTUSDBalance();
      user.setTUSDBalance(oldTUSDBalance + msg.value);

      emit DepositTUSD(oldTUSDBalance, user.getTUSDBalance());
    }

    function depositWBTC() payable public {
      SwapUser user = userData[msg.sender];

      uint oldWBTCBalance = user.getWBTCBalance();
      user.setWBTCBalance(oldWBTCBalance + msg.value);

      emit DepositWBTC(oldWBTCBalance, user.getWBTCBalance());
    }

    function getContractTUSDBalance() internal view returns (uint) {
      return IERC20(Constants.KOVAN_TUSD).balanceOf(address(this));
    }

    function getUContractWBTCBalance() internal view returns (uint) {
      return IERC20(Constants.KOVAN_WBTC).balanceOf(address(this));
    }

    function getContractETHBalance() internal view returns (uint) {
      return IERC20(Constants.KOVAN_WETH).balanceOf(address(this));
    }
}

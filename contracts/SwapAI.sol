// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

// 3rd-party library imports
import { KeeperCompatibleInterface } from "@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol";

// 1st-party project imports
import { ISwapAI } from "./interfaces/ISwapAI.sol";
import { SwapUser } from "./SwapUser.sol";
import { OracleCaller } from "./OracleCaller.sol";

contract SwapAI is ISwapAI, KeeperCompatibleInterface {
    address[] private userAddresses;
    mapping(address => SwapUser) private userData;
    OracleCaller internal oracleCaller;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval) public {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
    }

    function createUser() external override {
      if (userData[msg.sender].getUserAddress() == address(0)) {
        userData[msg.sender] = new SwapUser(msg.sender, true);
        userAddresses.push(msg.sender);
        emit CreateUser(true);
      } else {
        emit CreateUser(false);
      }
    } 

    function optInToggle() external override {
      userData[msg.sender].toggleUserOptInStatus();
      emit OptInToggle(userData[msg.sender].getUserOptInStatus());
    }

    function isAtleastOneUserOptIn() private view returns (bool) {
      for (uint i = 0; i < userAddresses.length; i++) {
        if (userData[userAddresses[i]].getUserOptInStatus())
          return true;
      }

      return false;
    }

    function getSwapEligibleUsers() public view returns (SwapUser[] memory) {
      // NOTE: To avoid having a storage array (i.e. extra gas cost), we're counting the items
      // to be filtered and then instantiating a memory-based array
      uint numEligibleUsers = 0;

      for (uint i = 0; i < userAddresses.length; i++) {
        SwapUser user = userData[userAddresses[i]];
        if (user.getUserOptInStatus())
          numEligibleUsers++;
      }

      SwapUser[] memory eligibleUsers = new SwapUser[](numEligibleUsers);

      uint j = 0;
      for (uint i = 0; i < userAddresses.length; i++) {
        SwapUser user = userData[userAddresses[i]];
        if (user.getUserOptInStatus()) {
          eligibleUsers[j++] = user;
        }
      }

      return eligibleUsers;
    }

    function swapSingleUserBalance() external override {
      // HACK: This form of array initialization is used to bypass a type cast error
      SwapUser[] memory currentUserDataOnly = new SwapUser[](1);
      currentUserDataOnly[0] = userData[msg.sender];

      oracleCaller.trySwapManual(currentUserDataOnly, false);
    }

    function swapAllUsersBalances(bool force) public override {
      oracleCaller.trySwapAuto(getSwapEligibleUsers(), force); 
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        bool hasIntervalPassed = (block.timestamp - lastTimeStamp) > interval;
        upkeepNeeded = hasIntervalPassed && isAtleastOneUserOptIn();
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        lastTimeStamp = block.timestamp;
        swapAllUsersBalances(false);
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    receive() external payable {}
}

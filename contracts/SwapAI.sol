// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

// 3rd-party library imports
import "@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol";

// 1st-party project imports
import "./ISwapAI.sol";
import "./SwapUser.sol";
import "./OracleCaller.sol";

contract SwapAI is ISwapAI, KeeperCompatibleInterface {
    address[] private userAddresses;
    mapping(address => SwapUser) private userData;
    OracleCaller internal oracleCaller;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval) public {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
    }

    function createUser() external override {
      if (userData[msg.sender].userAddress == address(0)) {
        userData[msg.sender] = SwapUser(msg.sender, true);
        userAddresses.push(msg.sender);
        emit CreateUser(true);
      } else {
        emit CreateUser(false);
      }
    } 

    function optInToggle() external override {
      userData[msg.sender].optInStatus = !userData[msg.sender].optInStatus;
      emit OptInToggle(userData[msg.sender].optInStatus);
    }

    function isAtleastOneUserOptIn() private returns (bool) {
      for (uint i = 0; i < userAddresses.length; i++) {
        if (userData[userAddresses[i]].optInStatus == true) {
          return true;
        } 
      }

      return false;
    }

    function getSwapEligibleUsers() public returns (SwapUser[] memory) {
      SwapUser[] memory eligibleUsers;

      for (uint i = 0; i < userAddresses.length; i++) {
        SwapUser user = userData[userAddresses[i]];
        if (user.optInStatus == true) {
          eligibleUsers.push(user);
        }
      }

      return eligibleUsers;
    }

    function swapSingleUserBalance() external override {
      uint[1] memory currentUserDataOnly = [userData[msg.sender]];
      oracleCaller.trySwapManual(currentUserDataOnly, false);
    }

    function swapAllUsersBalances(bool force) public override {
      oracleCaller.trySwapAuto(getSwapEligibleUsers(), force); 
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        bool hasIntervalPassed = (block.timestamp - lastTimeStamp) > interval;
        upkeepNeeded = hasIntervalPassed && isAtleastOneUserOptIn();
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        lastTimeStamp = block.timestamp;
        swapAllUsersBalances(false);
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    receive() external payable {}
}
